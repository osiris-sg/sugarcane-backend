// Prisma schema for Sugarcane Backend
// Uses Neon DB (PostgreSQL)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Telegram subscriber categories
enum SubscriptionCategory {
  STOCK       // Stock level and fault alerts
  MAINTENANCE // Maintenance activity (requires password)
}

// Telegram subscribers
model Subscriber {
  id           String               @id @default(cuid())
  chatId       String               @unique
  username     String?
  firstName    String?
  lastName     String?
  categories   SubscriptionCategory[]
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  @@index([chatId])
}

// Pending password verification for maintenance subscription
model PendingVerification {
  id        String   @id @default(cuid())
  chatId    String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime

  @@index([chatId])
}

// Notification log (optional - for tracking sent notifications)
model NotificationLog {
  id          String   @id @default(cuid())
  type        String   // "stock", "fault", "maintenance_login", "topup"
  deviceId    String?
  deviceName  String?
  message     String
  recipients  Int      // Number of recipients sent to
  createdAt   DateTime @default(now())

  @@index([type, createdAt])
}

// Device configuration (price, name linked to device ID)
model Device {
  id          String   @id @default(cuid())
  deviceId    String   @unique  // Terminal ID from the vending machine
  deviceName  String            // Display name (e.g., "116 Jln Tenteram")
  price       Int               // Price in cents (e.g., 250 = $2.50)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([deviceId])
}

// Stock levels for each device
model Stock {
  id          String    @id @default(cuid())
  deviceId    String    @unique  // Terminal ID from the vending machine
  deviceName  String             // Display name for easy reference
  quantity    Int       @default(0)   // Current stock count
  maxStock    Int       @default(80)  // Maximum stock capacity
  lastAlertAt DateTime?              // When last recurring alert was sent
  alertLevel  String?                // Current alert level (25/15/0)
  lastSaleAt  DateTime?              // When last sale occurred (for zero sales alert)
  updatedAt   DateTime  @updatedAt
  createdAt   DateTime  @default(now())

  @@index([deviceId])
}

// Orders from vending machines
model Order {
  id          String   @id @default(cuid())
  orderId     String            // Original order ID from device
  deviceId    String            // Terminal ID
  deviceName  String            // Device display name
  amount      Int               // Amount in cents
  quantity    Int      @default(1)  // Number of items
  payWay      String?           // Payment method (cash, card, etc.)
  isSuccess   Boolean  @default(true)
  createdAt   DateTime @default(now())

  @@index([deviceId, createdAt])
  @@index([createdAt])
}

// Stock history log (for tracking changes)
model StockHistory {
  id          String   @id @default(cuid())
  deviceId    String
  deviceName  String
  previousQty Int              // Stock before change
  newQty      Int              // Stock after change
  change      Int              // Difference (+/-)
  reason      String           // "sale", "topup", "remove", "convert", "adjustment"
  createdAt   DateTime @default(now())

  @@index([deviceId, createdAt])
}

// Storage levels for each device (raw sugarcane stored locally)
model Storage {
  id          String    @id @default(cuid())
  deviceId    String    @unique  // Terminal ID from the vending machine
  deviceName  String             // Display name for easy reference
  quantity    Int       @default(0)   // Current storage count
  updatedAt   DateTime  @updatedAt
  createdAt   DateTime  @default(now())

  @@index([deviceId])
}

// Storage history log (for tracking changes)
model StorageHistory {
  id          String   @id @default(cuid())
  deviceId    String
  deviceName  String
  previousQty Int              // Storage before change
  newQty      Int              // Storage after change
  change      Int              // Difference (+/-)
  reason      String           // "add", "remove", "convert"
  createdAt   DateTime @default(now())

  @@index([deviceId, createdAt])
}

// Issue types for maintenance tracking
enum IssueType {
  DEVICE_ERROR    // Device fault codes (E316, etc.)
  ZERO_SALES      // Zero sales detected by cron
}

// Issue status workflow
enum IssueStatus {
  OPEN            // Issue created, not yet responded to
  CHECKING        // Staff is checking (responded)
  RESOLVED        // Issue resolved
  UNRESOLVED      // Issue not resolved, escalated to manager
}

// Issue tracking for device errors and zero sales
model Issue {
  id                String      @id @default(cuid())
  deviceId          String
  deviceName        String
  type              IssueType

  // For DEVICE_ERROR type
  faultCode         String?     // E.g., "E316", "E50D"
  faultName         String?     // E.g., "Fruits out of stock"
  orderId           String?     // Associated order if any

  // For ZERO_SALES type
  timeBlock         String?     // E.g., "8am-10am"

  // Timestamps for KPI tracking
  triggeredAt       DateTime    @default(now())  // When issue was detected
  respondedAt       DateTime?   // When staff clicked "Checking"
  resolvedAt        DateTime?   // When staff clicked Resolved/Unresolved

  // Computed KPIs (stored for reporting)
  responseTimeMs    Int?        // respondedAt - triggeredAt
  resolutionTimeMs  Int?        // resolvedAt - respondedAt

  // Resolution info
  status            IssueStatus @default(OPEN)
  resolution        String?     // "resolved" or "unresolved"

  // Reminder tracking (3hr KPI, then hourly)
  lastReminderAt    DateTime?   // For hourly reminders after 3 hours
  reminderCount     Int         @default(0)

  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([deviceId, status])
  @@index([type, status])
  @@index([triggeredAt])
  @@index([status, lastReminderAt])
}

// Maintenance activity log (for clean/wash down and customer feedback)
model MaintenanceActivity {
  id              String    @id @default(cuid())
  deviceId        String
  deviceName      String
  activityType    String    // "clean_wash" or "customer_feedback"

  startedAt       DateTime
  completedAt     DateTime?
  durationMs      Int?      // completedAt - startedAt

  status          String    // "in_progress", "completed", "unresolved"
  notes           String?

  createdAt       DateTime  @default(now())

  @@index([deviceId, activityType])
  @@index([createdAt])
}
